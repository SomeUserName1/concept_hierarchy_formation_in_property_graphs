\chapter{Introduction}
\label{chap:intro}

\section{Motivation}

Graph query languages have become very popular in some domains recently, e.g.,
in the analysis of social networks.
In those domains people are interested in queries that relate many different
entities in a complex pattern.
Such queries are often difficult to express and understand for users in terms
of tables, rows and columns, as e.g, in SQL. However they can be directly
translated into a graph with (labeled) nodes for the entities and (typed) edges
for the relationships. As a result, there is growing interest in the employment
of graph query languages.

Graph query languages can be used on top of a relational database, using a
suitable mapping from graph queries to relational queries.
This approach has the advantage of reusing all the performance optimizations
developed for relational databases during the last decades.

Another approach is to use a graph database. Graph databases use graph
structures not only for querying, but also for storing and processing of the
data. Normally this means that relationships and entities are stored separately
and that physical pointers are used to reference entities.

Several empirical studies were conducted recently to compare the performance
of graph databases with mappings to relational databases.
Gubichev and Then\cite{gubichev_graph_2014} demonstrate that a mappping to the
relational database Virtuoso outperforms the graph databases Neo4j and
DEX/Sparksee for a set of pattern matching queries.
% Hölsch et al.\cite{holsch_performance_2017} define a set of analytical and
% pattern matching queries to compare the performance of the graph database Neo4j
% with two commercial relational databases.
Hölsch et al.\cite{holsch_performance_2017} show that two commercial
relational databases using a mapping are faster than Neo4j for analytical
queries and for pattern matching queries with relationship type constraints.
These test results indicate that suitable mappings to
relational databases currently outperform graph databases.

The worse performance of graph databases can partly be attributed to their
inferior query optimizers.
For instance, the optimizer of the Neo4j graph database fails to
choose a good execution plan for some simple queries \cite{holsch_algebra_2016}.
Consequently, there is a need for better query optimizers for graph databases.

In a currently ongoing research effort at the University of Konstanz, we
develop a new optimizer for the Neo4j graph database.
This optimizer will be based on the Cascades optimizer framework defined by
Graefe \cite{graefe_cascades_1995}.

The Cascades framework generates execution plans using equivalence rules on
a query algebra. Therefore, we have to define a query algebra for graph
databases. Hölsch et al.\cite{holsch_algebra_2016} have already defined two
operators of this algebra.
In this thesis, we formally define the missing operators and prove that our set of
operators is complete and well-defined.

In addition, the Cascades framework requires robust estimations of the result
cardinalities of each operator of this algebra. In this thesis, we propose
such estimations and evaluate them in the Neo4j graph database.

\section{Contributions}

We make two contributions in the field of graph query
optimization.

\subsection{A Graph Query Algebra}

Firstly, we define a graph query space in terms of subgraph homomorphisms.
Together with a set of query operators, the query space forms a graph query
algebra.
This query algebra is a formalization of a subset of the very popular
graph query language \emph{Cypher} \footnote{\url{http://www.opencypher.org/}}.
The graph algebra can be used in a graph DBMS for the same kind of tasks as
the relational algebra in a relational DBMS, e.g. for search space exploration
and statistical analysis.

\subsection{A Statistical Model to Estimate Result Cardinality}

Secondly, we propose a statistical model to estimate the result
cardinalities of the operators of the graph algebra.
We implement this model in the Neo4j graph database.

In contrast to Neo4j's own estimation model, our model does
not globally assume independence of node labels.
Using two helper data structures, it also yields sensible estimations if node
labels are disjoint or in a sublabel relation.
Additionally, the model is able to deal with strong dependencies
between node labels and the presence of relationships between nodes.

Because of missing statistics in
Neo4j and the early stage of development of our model, the query space covered
by the model is currently limited to (Cypher) single pattern queries
(CSP queries), that are cycle-free and only have one component.
Once these problems are solved, the model can be extended to cover
the whole query space.

A statistical analysis at the end of this thesis
shows the benefits of our model compared with the
current estimation model of Neo4j.
